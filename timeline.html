<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Timeline Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #1e1e1e;
            color: white;
            margin: 0;
            padding: 20px;
        }
        .controls {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            gap: 10px;
        }
        .tooltip {
            position: absolute;
            text-align: center;
            padding: 5px;
            font-size: 12px;
            background: lightgray;
            border: 1px solid gray;
            border-radius: 3px;
            pointer-events: none;
            opacity: 0;
        }
        .timeline-container {
            overflow-x: auto;
            border: 1px solid #ccc;
            border-radius: 5px;
        }
        .axis line,
        .axis path {
            stroke: #fff;
            shape-rendering: crispEdges;
        }
        .axis text {
            font-size: 12px;
            fill: white;
        }
        .grid-line {
            stroke: #555;
            stroke-dasharray: 2 2;
        }
        .legend {
            margin-top: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
        }
        .legend-item {
            display: flex;
            align-items: center;
        }
        .legend-color {
            width: 15px;
            height: 15px;
            margin-right: 5px;
            border: 1px solid #ccc;
        }
    </style>
</head>
<body>
    <div class="controls">
        <label for="start-date">Start Date:</label>
        <input type="date" id="start-date">
        <label for="end-date">End Date:</label>
        <input type="date" id="end-date">
        <button id="filter-btn">Apply Filter</button>
        <button id="reset-btn">Reset Filter</button>
        <button id="export-btn">Export as Image</button>
    </div>
    <div id="tooltip" class="tooltip"></div>
    <div class="timeline-container">
        <svg id="timeline-svg" width="1200" height="600"></svg>
    </div>
    <div class="legend" id="legend"></div>

    <script>
        const margin = { top: 50, right: 20, bottom: 100, left: 150 };
        const width = 1200 - margin.left - margin.right;
        const rowHeight = 40;

        const svg = d3.select("#timeline-svg")
            .attr("width", width + margin.left + margin.right)
            .append("g")
            .attr("transform", `translate(${margin.left}, ${margin.top})`);

        const tooltip = d3.select("#tooltip");
        let globalData = [];

        d3.csv("PatientInfo.csv").then(rawData => {
            const parseDate = d3.timeParse("%Y-%m-%d");
            rawData.forEach(d => {
                d.symptom_onset_date = parseDate(d.symptom_onset_date);
                d.confirmed_date = parseDate(d.confirmed_date);
                d.released_date = parseDate(d.released_date);
            });

            const groupedData = d3.group(rawData, d => d.province);
            globalData = Array.from(groupedData.entries()).map(([province, patients]) => ({
                province,
                patients
            }));

            drawTimeline(globalData);
            createLegend();
        });

        function drawTimeline(data) {
            svg.selectAll("*").remove();

            const totalHeight = data.length * rowHeight + margin.top + margin.bottom;
            d3.select("#timeline-svg").attr("height", totalHeight);

            const xScale = d3.scaleTime()
                .domain([
                    d3.min(data.flatMap(d => d.patients), d => d.symptom_onset_date),
                    d3.max(data.flatMap(d => d.patients), d => d.released_date)
                ])
                .range([0, width]);

            const yScale = d3.scaleBand()
                .domain(data.map(d => d.province))
                .range([0, totalHeight - margin.top - margin.bottom])
                .padding(0.1);

            const xAxis = d3.axisBottom(xScale).tickFormat(d3.timeFormat("%b %d")).ticks(d3.timeMonth.every(1));
            const yAxis = d3.axisLeft(yScale);

            svg.append("g")
                .attr("transform", `translate(0, ${totalHeight - margin.top - margin.bottom})`)
                .call(xAxis)
                .selectAll("text")
                .attr("text-anchor", "end")
                .attr("transform", "rotate(-45)");

            svg.append("g").call(yAxis);

            svg.selectAll(".grid-line")
                .data(yScale.domain())
                .enter()
                .append("line")
                .attr("class", "grid-line")
                .attr("x1", 0)
                .attr("x2", width)
                .attr("y1", d => yScale(d) + yScale.bandwidth() / 2)
                .attr("y2", d => yScale(d) + yScale.bandwidth() / 2);

            const eventColors = { symptom_onset_date: "red", confirmed_date: "orange", released_date: "green" };

            data.forEach(group => {
                const y = yScale(group.province) + yScale.bandwidth() / 2;

                group.patients.forEach(patient => {
                    svg.append("line")
                        .attr("x1", xScale(patient.symptom_onset_date))
                        .attr("x2", xScale(patient.released_date))
                        .attr("y1", y)
                        .attr("y2", y)
                        .attr("stroke", "gray")
                        .attr("stroke-width", 1);

                    Object.entries(eventColors).forEach(([event, color]) => {
                        svg.append("circle")
                            .attr("cx", xScale(patient[event]))
                            .attr("cy", y)
                            .attr("r", 5)
                            .attr("fill", color)
                            .on("mouseover", (event, d) => {
                                tooltip.style("opacity", 1)
                                    .html(`
                                        <strong>${group.province}</strong><br>
                                        <strong>${event.replace(/_/g, " ")}:</strong> ${d3.timeFormat("%Y-%m-%d")(patient[event])}
                                    `)
                                    .style("left", `${event.pageX + 10}px`)
                                    .style("top", `${event.pageY + 10}px`);
                            })
                            .on("mouseout", () => tooltip.style("opacity", 0));
                    });
                });
            });
        }

        function createLegend() {
            const legendData = [
                { label: "Symptom Onset", color: "red" },
                { label: "Confirmed", color: "orange" },
                { label: "Released", color: "green" }
            ];

            const legend = d3.select("#legend");
            legend.selectAll(".legend-item")
                .data(legendData)
                .enter()
                .append("div")
                .attr("class", "legend-item")
                .each(function(d) {
                    const item = d3.select(this);
                    item.append("div")
                        .attr("class", "legend-color")
                        .style("background-color", d.color);
                    item.append("span").text(d.label);
                });
        }

        document.getElementById("filter-btn").addEventListener("click", () => {
            const startDate = d3.timeParse("%Y-%m-%d")(document.getElementById("start-date").value);
            const endDate = d3.timeParse("%Y-%m-%d")(document.getElementById("end-date").value);

            if (!startDate || !endDate) {
                alert("Please select both start and end dates.");
                return;
            }

            const filteredData = globalData.map(group => ({
                province: group.province,
                patients: group.patients.filter(d => d.symptom_onset_date >= startDate && d.released_date <= endDate)
            })).filter(group => group.patients.length > 0);

            drawTimeline(filteredData);
        });

        document.getElementById("reset-btn").addEventListener("click", () => {
            drawTimeline(globalData);
        });

        document.getElementById("export-btn").addEventListener("click", () => {
            const svgData = new XMLSerializer().serializeToString(document.querySelector("#timeline-svg"));
            const blob = new Blob([svgData], { type: "image/svg+xml;charset=utf-8" });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = "timeline.svg";
            link.click();
        });
    </script>
</body>
</html>
